<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Swimbots ‚Äì Live Simulation</title>
  <link rel="stylesheet" href="../styles/main.css">
  <style>
    /* Clean simulation view styles */
    body {
      margin: 0;
      padding: 0;
      background: #000;
      overflow: hidden;
    }
    
    #canvas {
      width: 100vw;
      height: 100vh;
      display: block;
    }
    
    .controls-overlay {
      position: absolute;
      top: 10px;
      right: 10px;
      background: rgba(0, 0, 0, 0.7);
      padding: 10px;
      border-radius: 5px;
      color: white;
      font-family: Arial, sans-serif;
      font-size: 12px;
      transition: opacity 0.3s ease;
    }
    
    .controls-overlay.hidden {
      opacity: 0;
      pointer-events: none;
    }
    
    .controls-overlay button {
      background: #4CAF50;
      color: white;
      border: none;
      padding: 5px 10px;
      margin: 2px;
      border-radius: 3px;
      cursor: pointer;
      font-size: 11px;
    }
    
    .controls-overlay button:hover {
      background: #45a049;
    }
    
    .controls-overlay button.danger {
      background: #f44336;
    }
    
    .controls-overlay button.danger:hover {
      background: #da190b;
    }
    
    .toggle-ui {
      position: absolute;
      top: 10px;
      left: 10px;
      background: rgba(0, 0, 0, 0.5);
      border: none;
      color: white;
      padding: 5px 8px;
      border-radius: 3px;
      cursor: pointer;
      font-size: 11px;
    }
    
    .stats-mini {
      position: absolute;
      bottom: 10px;
      left: 10px;
      background: rgba(0, 0, 0, 0.7);
      padding: 8px;
      border-radius: 5px;
      color: white;
      font-family: Arial, sans-serif;
      font-size: 11px;
      line-height: 1.4;
      transition: opacity 0.3s ease;
    }
    
    .stats-mini.hidden {
      opacity: 0;
      pointer-events: none;
    }
  </style>
</head>
<body>
  <canvas id="canvas"></canvas>
  
  <!-- Toggle UI visibility button -->
  <button class="toggle-ui" onclick="toggleUI()">Toggle UI</button>
  
  <!-- Minimal controls overlay -->
  <div class="controls-overlay" id="controlsOverlay">
    <div>
      <button onclick="togglePause()">‚èØÔ∏è Pause/Resume</button>
      <button onclick="resetSimulation()" class="danger">üîÑ Reset</button>
    </div>
    <div style="margin-top: 5px;">
      <label>Food Rate: <input type="range" id="foodRateSlider" min="0" max="3" step="0.1" value="1" style="width: 80px;"></label>
    </div>
    <div style="margin-top: 3px;">
      <label>Mutation: <input type="range" id="mutationSlider" min="0" max="0.5" step="0.01" value="0.05" style="width: 80px;"></label>
    </div>
  </div>
  
  <!-- Mini stats display -->
  <div class="stats-mini" id="statsDisplay">
    <div>Bots: <span id="botCount">0</span></div>
    <div>Food: <span id="foodCount">0</span></div>
    <div>Generation: <span id="generation">1</span></div>
  </div>

  <script type="module">
    import { Simulation } from '../src/core/Simulation.js';
    import { Renderer } from '../src/rendering/Renderer.js';

    class CleanSimulationApp {
      constructor() {
        this.canvas = document.getElementById('canvas');
        this.simulation = new Simulation();
        this.renderer = new Renderer(this.canvas);
        this.isPaused = false;
        this.uiVisible = true;
        
        // Connect simulation with renderer for world size
        this.simulation.setRenderer(this.renderer);
        this.simulation.getWorldSize = () => this.renderer.getWorldSize();
        
        this.lastTime = performance.now();
        this.setupEventListeners();
        this.initialize();
      }

      setupEventListeners() {
        // Handle canvas clicks for bot selection
        this.canvas.addEventListener('click', (e) => {
          const rect = this.canvas.getBoundingClientRect();
          const x = e.clientX - rect.left;
          const y = e.clientY - rect.top;
          
          // Convert to world coordinates
          const worldSize = this.renderer.getWorldSize();
          const worldX = (x / rect.width) * worldSize.w;
          const worldY = (y / rect.height) * worldSize.h;
          
          // Find closest bot
          let closestBot = null;
          let closestDist = Infinity;
          
          for (const bot of this.simulation.bots) {
            const dist = Math.sqrt((bot.x - worldX) ** 2 + (bot.y - worldY) ** 2);
            if (dist < closestDist && dist < 20) { // 20 pixel threshold
              closestDist = dist;
              closestBot = bot;
            }
          }
          
          if (closestBot) {
            console.log('Selected bot:', closestBot);
            this.showBotDetails(closestBot);
            // You could emit this to a parent window or dashboard if needed
            if (window.parent !== window) {
              window.parent.postMessage({
                type: 'botSelected',
                bot: {
                  id: closestBot.id,
                  name: closestBot.name,
                  x: closestBot.x,
                  y: closestBot.y,
                  energy: closestBot.energy,
                  state: closestBot.state,
                  age: closestBot.age,
                  genes: closestBot.genes,
                  generation: closestBot.generation
                }
              }, '*');
            }
          }
        });

        // Food rate slider
        document.getElementById('foodRateSlider').addEventListener('input', (e) => {
          this.foodRate = parseFloat(e.target.value);
        });

        // Mutation rate slider
        document.getElementById('mutationSlider').addEventListener('input', (e) => {
          this.simulation.mutationRate = parseFloat(e.target.value);
        });

        // Keyboard shortcuts
        document.addEventListener('keydown', (e) => {
          switch(e.key) {
            case ' ':
              e.preventDefault();
              this.togglePause();
              break;
            case 'r':
              if (e.ctrlKey) {
                e.preventDefault();
                this.resetSimulation();
              }
              break;
            case 'h':
              this.toggleUI();
              break;
          }
        });
      }

      initialize() {
        this.foodRate = 1.0;
        this.simulation.reset();
        console.assert(this.simulation.bots.length > 0, '[Simulation] no bots after reset');
        this.startGameLoop();
      }

      startGameLoop() {
        const frame = () => {
          const now = performance.now();
          let dt = (now - this.lastTime) / 1000;
          this.lastTime = now;
          dt = Math.min(dt, 0.05); // Cap delta time
          
          const worldSize = this.renderer.getWorldSize();
          
          if (!this.isPaused) {
            this.simulation.step(dt, worldSize.w, worldSize.h, this.foodRate);
          }
          
          this.renderer.render(this.simulation, { showNames: this.uiVisible });
          this.updateStats();
          
          requestAnimationFrame(frame);
        };
        
        requestAnimationFrame(frame);
      }

      updateStats() {
        if (!this.uiVisible) return;
        
        document.getElementById('botCount').textContent = this.simulation.bots.length;
        document.getElementById('foodCount').textContent = this.simulation.food.length;
        
        // Calculate generation (rough estimate based on average age)
        const avgAge = this.simulation.bots.reduce((sum, bot) => sum + bot.age, 0) / this.simulation.bots.length;
        const generation = Math.floor(avgAge / 30) + 1; // Assuming 30 seconds per generation
        document.getElementById('generation').textContent = generation;
      }

      togglePause() {
        this.isPaused = !this.isPaused;
      }

      resetSimulation() {
        this.simulation.reset();
      }

      showBotDetails(bot) {
        const finSizes = {
          tail: (0.9 + bot.genes.E * 0.8).toFixed(2),
          pectoral: (0.8 + bot.genes.O * 0.6).toFixed(2),
          dorsal: (0.7 + bot.genes.C * 0.5).toFixed(2),
          pelvic: (0.6 + bot.genes.N * 0.7).toFixed(2)
        };
        
        const info = `
üêü ${bot.name}
Generation: ${bot.generation || 0}
Age: ${Math.floor(bot.age)}s
Energy: ${Math.round(bot.energy * 100)}%
State: ${bot.state}

üß¨ OCEAN Traits & Fins:
O: ${bot.genes.O.toFixed(2)} ‚Üí Pectoral fins: ${finSizes.pectoral}x
C: ${bot.genes.C.toFixed(2)} ‚Üí Stability fins: ${finSizes.dorsal}x  
E: ${bot.genes.E.toFixed(2)} ‚Üí Tail display: ${finSizes.tail}x
A: ${bot.genes.A.toFixed(2)} ‚Üí Swimming efficiency
N: ${bot.genes.N.toFixed(2)} ‚Üí Nervous fins: ${finSizes.pelvic}x

üèä Performance:
Speed: ${bot.baseSpeed.toFixed(1)} units/s
Maneuverability: ${bot.maxTurnRate.toFixed(2)}
Efficiency: ${bot.drag.toFixed(3)}
        `;
        alert(info);
      }

      toggleUI() {
        this.uiVisible = !this.uiVisible;
        const overlay = document.getElementById('controlsOverlay');
        const stats = document.getElementById('statsDisplay');
        
        if (this.uiVisible) {
          overlay.classList.remove('hidden');
          stats.classList.remove('hidden');
        } else {
          overlay.classList.add('hidden');
          stats.classList.add('hidden');
        }
      }
    }

    // Global functions for button clicks
    window.togglePause = () => app.togglePause();
    window.resetSimulation = () => app.resetSimulation();
    window.toggleUI = () => app.toggleUI();

    // Initialize the application
    const app = new CleanSimulationApp();
    window.app = app; // Make accessible for debugging
  </script>
</body>
</html>
